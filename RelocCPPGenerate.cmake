# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
# SPDX-License-Identifier: BSD-3-Clause

# reloc_cpp_generate(<library>
#                    GENERATED_HEADER <generated_header>
#                    GENERATED_FUNCTION <generated_function>
#                    DISABLE_RELOCATABLE <disable_relocatable>
#                    EXPORT_MACRO_INCLUDE <export_macro_include>
#                    EXPORT_MACRO_NAME <export_macro_name>
#                    VERBOSE <verbose>)
#
function(RELOC_CPP_GENERATE _library)
  set(_options)
  set(_oneValueArgs
    GENERATED_HEADER
    GENERATED_FUNCTION
    DISABLE_RELOCATABLE
    EXPORT_MACRO_INCLUDE
    EXPORT_MACRO_NAME
    VERBOSE
  )
  set(_multiValueArgs )
  cmake_parse_arguments(RCG "${_options}" "${_oneValueArgs}" "${_multiValueArgs}" ${ARGN} )

  if(NOT DEFINED RCG_GENERATED_HEADER)
    message(FATAL_ERROR "reloc_cpp_generate: missing parameter GENERATED_HEADER")
  endif()

  if(NOT DEFINED RCG_GENERATED_FUNCTION)
    message(FATAL_ERROR "reloc_cpp_generate: missing parameter GENERATED_FUNCTION")
  endif()

  if(DEFINED RCG_EXPORT_MACRO_INCLUDE)
    set(RCG_EXPORT_MACRO_INCLUDE_LINE "#include <${RCG_EXPORT_MACRO_INCLUDE}>")
  else()
    set(RCG_EXPORT_MACRO_INCLUDE_LINE "")
  endif()

  if(DEFINED RCG_EXPORT_MACRO_NAME)
    set(RCG_EXPORT_MACRO_NAME "")
  endif()

  if(DEFINED RCG_EXPORT_MACRO_NAME)
    set(RCG_EXPORT_MACRO_NAME_WITH_SPACE "${RCG_EXPORT_MACRO_NAME} ")
  else()
    set(RCG_EXPORT_MACRO_NAME_WITH_SPACE "${RCG_EXPORT_MACRO_NAME}")
  endif()

  if(NOT TARGET ${_library})
    message(FATAL_ERROR "reloc_cpp_generate: library ${_library} does not exist")
  endif()

  if(NOT TARGET ${_library})
    message(FATAL_ERROR "reloc_cpp_generate: library ${_library} does not exist")
  endif()

  get_target_property(target_type ${_library} TYPE)
  if(NOT (target_type STREQUAL "STATIC_LIBRARY" OR target_type STREQUAL "MODULE_LIBRARY" OR target_type STREQUAL "SHARED_LIBRARY"))
    message(FATAL_ERROR "reloc_cpp_generate: library ${_library} is of unsupported type ${target_type}")
  endif()

  # Get generated .cpp name
  get_filename_component(RCG_GENERATED_HEADER_DIRECTORY ${RCG_GENERATED_HEADER} DIRECTORY)
  get_filename_component(RCG_GENERATED_HEADER_NAME_WE ${RCG_GENERATED_HEADER} NAME_WE)
  get_filename_component(RCG_GENERATED_HEADER_NAME ${RCG_GENERATED_HEADER} NAME)
  set(RCG_GENERATED_CPP ${RCG_GENERATED_HEADER_DIRECTORY}/${RCG_GENERATED_HEADER_NAME_WE}.cpp)

  if (DEFINED RCG_VERBOSE AND RCG_VERBOSE)
    message(STATUS "reloc_cpp_generate: RCG_GENERATED_CPP=${RCG_GENERATED_CPP}")
  endif()

  # Decompose scoped function name in unscoped name and namespaces
  string(REPLACE "::" ";" RCG_GENERATED_FUNCTION_NAMESPACES ${RCG_GENERATED_FUNCTION})
  list(POP_BACK RCG_GENERATED_FUNCTION_NAMESPACES RCG_GENERATED_FUNCTION_UNSCOPED)

  # Generate namespace-related lines
  set(RCG_HEADER_OPEN_NAMESPACES "")
  set(RCG_HEADER_CLOSE_NAMESPACES "")

  foreach(RCG_NAMESPACE IN ITEMS ${RCG_GENERATED_FUNCTION_NAMESPACES})
    string(APPEND RCG_HEADER_OPEN_NAMESPACES "namespace ${RCG_NAMESPACE} {\n")
    string(APPEND RCG_HEADER_CLOSE_NAMESPACES "}\n")
  endforeach()

  # Write header
  file(GENERATE OUTPUT "${RCG_GENERATED_HEADER}"
       CONTENT
"// This file is automatically generated reloc_cpp_generate CMake function.
#pragma once

#include <optional>
#include <string>

${RCG_EXPORT_MACRO_INCLUDE_LINE}

${RCG_HEADER_OPEN_NAMESPACES}

${RCG_EXPORT_MACRO_NAME_WITH_SPACE}std::optional<std::string> ${RCG_GENERATED_FUNCTION_UNSCOPED}();

${RCG_HEADER_CLOSE_NAMESPACES}
")

  # Write cpp for shared or module library type
  if (target_type STREQUAL "MODULE_LIBRARY" OR target_type STREQUAL "SHARED_LIBRARY" AND NOT RCG_DISABLE_RELOCATABLE)
    # We can't query the LOCATION property of the target due to https://cmake.org/cmake/help/v3.25/policy/CMP0026.html
    # We can only access the directory of the library at generation time via $<TARGET_FILE_DIR:tgt>

    file(GENERATE OUTPUT "${RCG_GENERATED_CPP}"
         CONTENT
"// This file is automatically generated reloc_cpp_generate CMake function.
#include \"${RCG_GENERATED_HEADER_NAME}\"

#include <filesystem>

#ifdef _WIN32
#include <windows.h>
#endif

#include <iostream>

std::optional<std::string> ${RCG_GENERATED_FUNCTION}()
{
    std::error_code fs_error;

    // Get location of the library
    std::filesystem::path library_location;
#ifndef _WIN32
    Dl_info address_info;
    int res_val = dladdr(reinterpret_cast<void *>(&${RCG_GENERATED_FUNCTION}), &info);
    if (info.dli_fname && res_val > 0)
    {
      library_location = info.dli_fname;
    }
    else
    {
      return {};
    }
#else
    // See
    char module_path[MAX_PATH];
    HMODULE hm = NULL;

    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
        GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
        (LPCSTR) &${RCG_GENERATED_FUNCTION}, &hm) == 0)
    {
        return {};
    }
    if (GetModuleFileNameA(hm, module_path, sizeof(module_path)) == 0)
    {
        return {};
    }

    library_location = std::string(module_path);
#endif

    const std::filesystem::path library_directory = library_location.parent_path();

    // Given the library_directory, return the install prefix via the relative path
#ifndef _WIN32
    const std::filesystem::path rel_path_from_install_prefix_to_lib = std::string(\"${CMAKE_INSTALL_LIBDIR}\");
#else
    const std::filesystem::path rel_path_from_install_prefix_to_lib = std::string(\"${CMAKE_INSTALL_BINDIR}\");
#endif
    const std::filesystem::path rel_path_from_lib_to_install_prefix =
        std::filesystem::relative(std::filesystem::current_path(), std::filesystem::current_path() / rel_path_from_install_prefix_to_lib, fs_error);
    // TODO(traversaro): handle fs_error errors
    const std::filesystem::path install_prefix = library_directory / rel_path_from_lib_to_install_prefix;
    const std::filesystem::path install_prefix_canonical = std::filesystem::canonical(install_prefix, fs_error);
    // TODO(traversaro): handle fs_error errors

    // Return install prefix
    return install_prefix_canonical.string();
}
")
  else()
    # For static library, fallback to just provide return CMAKE_INSTALL_PREFIX
    file(GENERATE OUTPUT "${RCG_GENERATED_CPP}"
         CONTENT
"// This file is automatically generated reloc_cpp_generate CMake function.

#include \"${RCG_GENERATED_HEADER_NAME}\"

std::optional<std::string> ${RCG_GENERATED_FUNCTION}()
{
  return \"${CMAKE_INSTALL_PREFIX}\";
}
")
endif()

  # Add cpp to library
  target_sources(${_library} PRIVATE ${RCG_GENERATED_CPP})

  # Specify that we need C++17 features
  target_compile_features(${_library} PUBLIC cxx_std_17)

  # Link dl due to the use of dladdr
  if(NOT WIN32)
    target_link_libraries(${_library} PRIVATE ${CMAKE_DL_LIBS})
  endif()

endfunction()
